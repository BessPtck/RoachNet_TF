import os
import shutil
import math
import ParseLn



# class takes the stamps generated by StampsGen and puts them into the background directory
# it also generates all the NNet directories and the masterKey and _sig and _bak key files such that stamps that are similar are not used as background
# and the masterkey files in the NNet directories

class StampPreFeed:
    m_baseDir=""
    m_bakDir=""
    m_sigDir=""
    m_nnetDir=""
    m_sigSufix=""
    m_bakSufix=""
   
    m_ang_minDelta=0.0
    m_invR_minDelta=0.0 #R is normalized to dimensions of image

    m_maxNNet_rm_cnt=0

    def __init__(self, 
                 ang_minDelta=math.pi/12.0,
                 invR_minDelta=0.2,#normalized in units of D
                 baseDir="Stamps/L0",
                 sigDir="Sig",
                 bakDir="Bak",
                 nnetDir="NNet",
                 sigSufix="_sig",
                 bakSufix="_bak",
                 maxNNet_rm_cnt=300):
        self.m_ang_minDelta=ang_minDelta
        self.m_invR_minDelta=invR_minDelta
        self.m_baseDir=baseDir
        self.m_bakDir=bakDir
        self.m_sigDir=sigDir
        self.m_nnetDir=nnetDir
        self.m_sigSufix=sigSufix
        self.m_bakSufix=bakSufix

    def run():
        clearDirs()
        genBak()
        masterKeyPath = m_baseDir+"/"+g_const_Stamp_masterFile+g_const_Stamp_keySufix
        masterKey_arr2=ParseLn.readLines(masterKeyPath)
        if(len(masterKey_arr2)<1):
            return False
        s_masterKey=masterKey_arr2[0]
        imgDim=s_masterKey[1]
        return genNNets(imgDim,s_masterKey)

    def clearDirs():
        #baseDir=g_const_Stamp_baseDir+"/"+g_const_Stamp_stampBaseDir+"/"
        bakDirPath=m_baseDir+"/"+m_bakDir
        if os.path.exists(bakDirPath):
            shutil.rmtree(bakDirPath)
        for net_i in range(m_maxNNet_rm_cnt):
            nnetDirPath = m_baseDir+"/"+m_nnetDir+ParseLn.numberToString(net_i)
            if os.path.exists(nnetDirPath):
                shutil.rmtree(nnetDirPath)
            else:
                break

    #nothing is done with background in this case except to copy the signal
    def genBak():
        bakDirPath=m_baseDir+"/"+m_bakDir
        os.mkdir(bakDirPath)
        #copy all the signal files
        src_files=os.listdir(m_baseDir)
        for file_name in src_files:
            src_path = os.path.join(m_baseDir,file_name)
            dest_path=os.path.join(bakDirPath,file_name)
            if os.path.isfile(src_path) and file_name.find(g_const_Stamp_imgFileSufix)>1:
                shutil.copyfile(src_path,dest_path)

    def isNonOverlap(imgDim, s_sigKey, s_bakcandKey):
        deltaAng_good=True
        deltaAng=abs(s_sigKey[1]-s_bakcandKey[1])
        if deltaAng<m_ang_minDelta:
            deltaAng_good=False
        invRDelta_good=True
        sigRNorm=s_sigKey[6]/imgDim
        bakRNorm=s_bakcandKey[6]/imgDim
        if(sigRNorm<=0.0 or bakRNorm<=0.0):
            return False
        invRDelta = abs(sigRNorm-bakRNorm)
        if(invRDelta<m_invR_minDelta):
            invRDelta_good=False
        return deltaAng_good or invRDelta_good

    #NNet dir doesn't at this stage contain any img files, however it does contain the
    #key files that point to each sig in the Stamp dir (_sig file) and bak img in the Bak dir (_bak file)
    #these files indicate which sig is to be used and which Baks are overlaps
    #it also contains the master key that records how many sig and background files are being used
    #
    #in this instance only one signal will be used from the signal dir and the rest of the non-overlaping img
    #files will become the background
    def genNNet(nnet_num, imgDim, s_masterKey, s_sigkey, arr_allKeys):
        NNetDirPath=m_baseDir+"/"+m_nnetDir+ParseLn.numberToString(nnet_num)
        os.mkdir(NNetDirPath)

        len_key=len(s_sigkey)
        FinSigKeys_arr=[[0]*len_key]
        for el_i in range(len_key):
            FinSigKeys[0][el_i]=s_sigkey[el_i]
        s_sigKey[2]=1.0

        FinBakKeys_arr=[]
        for s_bakKey in arr_allKeys:
            if isNonOverlap(imgDim, s_sigKey, s_bakKey):
                s_bakKey[2]=-1.0
                FinBakKeys_arr.append(s_bakKey)

        #write the keys files
        N_sig=len(FinSigKeys_arr)
        N_bak=len(FinBakKeys_arr)
        sigFilePath = NNetDirPath+"/"+g_const_Stamp_keyFile+m_sigSufix+g_const_Stamp_keySufix
        bakFilePath = NNetDirPath+"/"+g_const_Stamp_keyFile+m_bakSufix+g_const_Stamp_keySufix
        ParseLn.writeLineS(sigFilePath,FinSigKeys_arr)
        ParseLn.writeLineS(bakFilePath,FinBakKeys_arr)

        #write the masterkey file
        s_masterKey[3]=N_sig+N_bak
        s_masterKey[4]=N_sig
        s_masterKey[5]=N_bak
        masterFilePath = NNetDirPath+"/"+g_const_Stamp_masterFile+g_const_Stamp_keySufix
        ParseLn.writeLine(masterFilePath,s_masterKey)

        #now make the unfilled Sig and Bak dirs that are under the NNet## dir
        NNetDirSigPath = NNetDirPath + "/" + m_sigDir
        NNetDirBakPath = NNetDirPath + "/" + m_bakDir
        os.mkdir(NNetDirSigPath)
        os.mkdir(NNetDirBakPath)


    def genNNets(imgDim, s_masterKey):
        keysFilePath=m_baseDir+"/"+g_const_Stamp_keyFile+g_const_Stamp_keySufix
        arr_sigKeys = ParseLn.readLines(keysFilePath)
        if(len(arr_sigKeys<1)):
            return False
        for s_sigKey in arr_sigKeys:
            nnetNum=s_sigKey[0]
            genNNet(nnetNum,imgDim,s_masterKey,s_sigKey,arr_sigKeys)
        return True
    

